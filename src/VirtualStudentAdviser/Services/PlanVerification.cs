using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.AspNetCore.Routing;
using VirtualStudentAdviser.Controllers;
using VirtualStudentAdviser.Models;
using VirtualStudentAdviser.Services;

namespace VirtualStudentAdviser
{




    public static class PlanVerification
    {


        public static PlanVerificationInfo runTests(List<StudyPlan> studyPlan, Dictionary<int, int[][]> prereqs, int[] requiredCourses, List<Course> courses,int[] completedCourses, VirtualAdviserContext vac)
        {
            PlanVerificationInfo result = new PlanVerificationInfo();
            int planId = studyPlan[0].PlanId;

            result.planId = planId;
            List<int> degreeFulfilledCourses = Output_DegreeFulfilled(studyPlan, requiredCourses.ToList());
            Dictionary<int, List<int>> prereqsCorrect = Output_CorrectOrderOfPreReq(studyPlan, prereqs,completedCourses);

            List<int> incorrectScheduling = Ouput_CoursesScheduledCorrectily(studyPlan, vac);

            foreach (var course in degreeFulfilledCourses)
            {
                result.incorrectScheduling.Add("Core Course " + getCourseNumberFromId(course, courses) + " is not scheduled");
            }

            foreach (var key in prereqsCorrect.Keys)
            {
                foreach (var value in prereqsCorrect[key])
                {
                    result.unfulfilledPrereqs.Add(getCourseNumberFromId(key, courses) + " is missing prereq " + getCourseNumberFromId(value, courses));

                }
            }



            foreach (var course in incorrectScheduling)
            {
                result.incorrectScheduling.Add("Course " + getCourseNumberFromId(course, courses) + " is scheduled in a quarter it is not offered");
            }
            return result;
        }

        private static List<int> Ouput_CoursesScheduledCorrectily(List<StudyPlan> studyPlan, VirtualAdviserContext vac)
        {
            List<int> result = new List<int>();
            foreach (var course in studyPlan)
            {
                var value = vac.CourseTime.Where(c => c.CourseId == course.CourseId);
                if (!value.Any(c => c.QuarterId == course.QuarterId))
                {
                    result.Add(course.CourseId);
                }

            }
            return result;
        }

        // controls if the output.json is regenerated by RecEngine algorithm
        static int startQtr = 1;
        static int endQtr = 4;



        // recengine returns a result
        public static bool Output_NotEmpty(List<StudyPlan> studyPlan)
        {

            return studyPlan.Count != 0;
        }


        private static string getCourseNumberFromId(int courseId, List<Course> courses)
        {
            var course = courses.Where(c => c.CourseId == courseId).Select(m => m.CourseNumber).First();

            return course.Trim();
        }
        // returns the next quater after qtr.
        private static int getNextQuarter(int qtr)
        {
            if (qtr < startQtr || qtr > endQtr)
            {
                return -1;
            }
            if (qtr == endQtr)
            {
                return startQtr;
            }
            if (qtr >= startQtr)
            {
                return qtr + 1;
            }

            return qtr;
        }

        // makes sure the quarters are in the correct order

        public static bool Output_CourseInfo_QuartersCorrectOrder(List<StudyPlan> studyPlan)
        {
            if (studyPlan.Count == 0)
            {
                return true;
            }
            int lastQtr = studyPlan[0].QuarterId;
            int lastYear = studyPlan[0].YearId;
            for (int i = 1; i < studyPlan.Count; i++)
            {

                int qtr = studyPlan[i].QuarterId;
                int year = studyPlan[i].YearId;
                if (qtr == lastQtr)
                {
                    continue;
                }

                int expectedQtr = getNextQuarter(lastQtr);


                if (!(qtr == expectedQtr && expectedQtr != -1 || year > lastYear || (lastQtr < qtr && lastYear == year)))
                {
                    return false;

                }


                lastQtr = qtr;
                lastYear = year;
            }
            return true;
        }


        // returns the next year after the current qtr and year
        private static int getNextYear(int year, int qtr)
        {
            int nextQuarter = getNextQuarter(qtr);

            if (nextQuarter == 2)
            {
                return year + 1;
            }

            return year;

        }

        // makes sure the quarters are in the correct order

        public static bool Output_CourseInfo_YearsCorrectOrder(List<StudyPlan> studyPlan)
        {
            if (studyPlan.Count == 0)
            {
                return true;
            }
            int lastQtr = studyPlan[0].QuarterId;
            int lastYr = studyPlan[0].YearId;

            for (int i = 1; i < studyPlan.Count; i++)
            {
                int qtr = studyPlan[i].QuarterId;

                int year = studyPlan[i].YearId;

                // the quarter has more than one course scheduled
                if (qtr == lastQtr && year == lastYr)
                {
                    continue;
                }




                int expectedYear = getNextYear(lastYr, lastQtr);

                if (!(expectedYear == year || year > lastYr || (lastQtr < qtr && lastYr == year)))
                {
                    return false;
                }

                lastQtr = qtr;
                lastYr = year;

            }
            return true;
        }



        // tests of transfer degree is fulfilled

        public static List<int> Output_DegreeFulfilled(List<StudyPlan> studyPlan, List<int> requiredCourses)
        {
            for (int i = 0; i < studyPlan.Count; i++)
            {

                int val = studyPlan[i].CourseId;
                requiredCourses.Remove(val);
            }
            return requiredCourses;
        }

        // all the classes have their prereqs satisfied
        public static Dictionary<int, List<int>> Output_CorrectOrderOfPreReq(List<StudyPlan> studyPlan,
            Dictionary<int, int[][]> prereq, int[] takenCourses)
        {
            // group plan by quarters
            List<List<int>> quarters = studyPlan.GroupBy(m => new { m.QuarterId, m.YearId }).Select(grp => grp.Select(m => m.CourseId).ToList()).ToList();
            Stack<List<int>> s = new Stack<List<int>>(quarters);
            Dictionary<int, List<int>> result = new Dictionary<int, List<int>>();
            while (s.Count > 0)
            {
                List<int> currQuarter = s.Pop();
                var r = s.SelectMany(m => m).Concat(takenCourses).ToList();

                foreach (var c in currQuarter)
                {

                    int[][] coursePrereqs = getPrereqGroups(prereq, c);
                    bool satisfied = false;
                    List<int> intersect = null;
                    foreach (var v in coursePrereqs)
                    {
                       
                       intersect = r.Intersect(v.ToList()).ToList();
                       satisfied = intersect.Count == v.Length;
                        
                      if (satisfied)
                        {
                           break;
                        }

                    }

                    if (!satisfied && coursePrereqs.Length != 0 )
                    {
                        var lastPrereqGroup = coursePrereqs.Last();
                            if (!result.ContainsKey(c))
                            result.Add(c, new List<int>());
                        result[c].AddRange(lastPrereqGroup.Except(intersect));

                    }

                }

            }
           
            return result;
        }



        private static int[][] getPrereqGroups(Dictionary<int, int[][]> prereqs, int courseId)
        {
            if(prereqs.ContainsKey(courseId))
                return prereqs[courseId];
            return new int[0][];
        }
    }

}

